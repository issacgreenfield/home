<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    <meta name="generator" content="pdoc 0.7.4" />
    <title>PiMan API documentation</title>
    <meta name="description" content="" />
    <link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
    <link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
    <style>
        .flex {
            display: flex !important
        }

        body {
            line-height: 1.5em
        }

        #content {
            padding: 20px
        }

        #sidebar {
            padding: 30px;
            overflow: hidden
        }

        .http-server-breadcrumbs {
            font-size: 130%;
            margin: 0 0 15px 0
        }

        #footer {
            font-size: .75em;
            padding: 5px 30px;
            border-top: 1px solid #ddd;
            text-align: right
        }

        #footer p {
            margin: 0 0 0 1em;
            display: inline-block
        }

        #footer p:last-child {
            margin-right: 30px
        }

        h1,
        h2,
        h3,
        h4,
        h5 {
            font-weight: 300
        }

        h1 {
            font-size: 2.5em;
            line-height: 1.1em
        }

        h2 {
            font-size: 1.75em;
            margin: 1em 0 .50em 0
        }

        h3 {
            font-size: 1.4em;
            margin: 25px 0 10px 0
        }

        h4 {
            margin: 0;
            font-size: 105%
        }

        a {
            color: #058;
            text-decoration: none;
            transition: color .3s ease-in-out
        }

        a:hover {
            color: #e82
        }

        .title code {
            font-weight: bold
        }

        h2[id^="header-"] {
            margin-top: 2em
        }

        .ident {
            color: #900
        }

        pre code {
            background: #f8f8f8;
            font-size: .8em;
            line-height: 1.4em
        }

        code {
            background: #f2f2f1;
            padding: 1px 4px;
            overflow-wrap: break-word
        }

        h1 code {
            background: transparent
        }

        pre {
            background: #f8f8f8;
            border: 0;
            border-top: 1px solid #ccc;
            border-bottom: 1px solid #ccc;
            margin: 1em 0;
            padding: 1ex
        }

        #http-server-module-list {
            display: flex;
            flex-flow: column
        }

        #http-server-module-list div {
            display: flex
        }

        #http-server-module-list dt {
            min-width: 10%
        }

        #http-server-module-list p {
            margin-top: 0
        }

        .toc ul,
        #index {
            list-style-type: none;
            margin: 0;
            padding: 0
        }

        #index code {
            background: transparent
        }

        #index h3 {
            border-bottom: 1px solid #ddd
        }

        #index ul {
            padding: 0
        }

        #index h4 {
            font-weight: bold
        }

        #index h4+ul {
            margin-bottom: .6em
        }

        @media (min-width:200ex) {
            #index .two-column {
                column-count: 2
            }
        }

        @media (min-width:300ex) {
            #index .two-column {
                column-count: 3
            }
        }

        dl {
            margin-bottom: 2em
        }

        dl dl:last-child {
            margin-bottom: 4em
        }

        dd {
            margin: 0 0 1em 3em
        }

        #header-classes+dl>dd {
            margin-bottom: 3em
        }

        dd dd {
            margin-left: 2em
        }

        dd p {
            margin: 10px 0
        }

        .name {
            background: #eee;
            font-weight: bold;
            font-size: .85em;
            padding: 5px 10px;
            display: inline-block;
            min-width: 40%
        }

        .name:hover {
            background: #e0e0e0
        }

        .name>span:first-child {
            white-space: nowrap
        }

        .name.class>span:nth-child(2) {
            margin-left: .4em
        }

        .inherited {
            color: #999;
            border-left: 5px solid #eee;
            padding-left: 1em
        }

        .inheritance em {
            font-style: normal;
            font-weight: bold
        }

        .desc h2 {
            font-weight: 400;
            font-size: 1.25em
        }

        .desc h3 {
            font-size: 1em
        }

        .desc dt code {
            background: inherit
        }

        .source summary,
        .git-link-div {
            color: #666;
            text-align: right;
            font-weight: 400;
            font-size: .8em;
            text-transform: uppercase
        }

        .source summary>* {
            white-space: nowrap;
            cursor: pointer
        }

        .git-link {
            color: inherit;
            margin-left: 1em
        }

        .source pre {
            max-height: 500px;
            overflow: auto;
            margin: 0
        }

        .source pre code {
            font-size: 12px;
            overflow: visible
        }

        .hlist {
            list-style: none
        }

        .hlist li {
            display: inline
        }

        .hlist li:after {
            content: ',\2002'
        }

        .hlist li:last-child:after {
            content: none
        }

        .hlist .hlist {
            display: inline;
            padding-left: 1em
        }

        img {
            max-width: 100%
        }

        .admonition {
            padding: .1em .5em;
            margin-bottom: 1em
        }

        .admonition-title {
            font-weight: bold
        }

        .admonition.note,
        .admonition.info,
        .admonition.important {
            background: #aef
        }

        .admonition.todo,
        .admonition.versionadded,
        .admonition.tip,
        .admonition.hint {
            background: #dfd
        }

        .admonition.warning,
        .admonition.versionchanged,
        .admonition.deprecated {
            background: #fd4
        }

        .admonition.error,
        .admonition.danger,
        .admonition.caution {
            background: lightpink
        }
    </style>
    <style media="screen and (min-width: 700px)">
        @media screen and (min-width:700px) {
            #sidebar {
                width: 30%
            }

            #content {
                width: 70%;
                max-width: 100ch;
                padding: 3em 4em;
                border-left: 1px solid #ddd
            }

            pre code {
                font-size: 1em
            }

            .item .name {
                font-size: 1em
            }

            main {
                display: flex;
                flex-direction: row-reverse;
                justify-content: flex-end
            }

            .toc ul ul,
            #index ul {
                padding-left: 1.5em
            }

            .toc>ul>li {
                margin-top: .5em
            }
        }
    </style>
    <style media="print">
        @media print {
            #sidebar h1 {
                page-break-before: always
            }

            .source {
                display: none
            }
        }

        @media print {
            * {
                background: transparent !important;
                color: #000 !important;
                box-shadow: none !important;
                text-shadow: none !important
            }

            a[href]:after {
                content: " ("attr(href) ")";
                font-size: 90%
            }

            a[href][title]:after {
                content: none
            }

            abbr[title]:after {
                content: " ("attr(title) ")"
            }

            .ir a:after,
            a[href^="javascript:"]:after,
            a[href^="#"]:after {
                content: ""
            }

            pre,
            blockquote {
                border: 1px solid #999;
                page-break-inside: avoid
            }

            thead {
                display: table-header-group
            }

            tr,
            img {
                page-break-inside: avoid
            }

            img {
                max-width: 100% !important
            }

            @page {
                margin: 0.5cm
            }

            p,
            h2,
            h3 {
                orphans: 3;
                widows: 3
            }

            h1,
            h2,
            h3,
            h4,
            h5,
            h6 {
                page-break-after: avoid
            }
        }
    </style>
</head>

<body>
    <main>
        <article id="content">
            <header>
                <h1 class="title">Module <code>PiMan</code></h1>
            </header>
            <section id="section-intro">
                <details class="source">
                    <summary>
                        <span>Expand source code</span>
                    </summary>
                    <pre><code class="python"># ****************************************************
# Copyright: 2020 Team Visualizer (Carlos Miguel Sayao, Connor Bettermann, Issac Greenfield, Madeleine Elyea, Tanner Sundwall, Ted Moore, Prerna Agarwal)
# License: MIT
# ****************************************************
# Purpose:  Global command buffer queue data structure.
# Purpose:  manages all functionality of the Pi and our program’s processes post-boot
#           Retains boolean representation of status as “Leader” otherwise is “Follower”
#           If “leadc_queue.IsLeader == True), listens for mouse inputs and sends commands out through ethernet
#           If “followc_queue.IsLeader == False), listens for ethernet data and follows those commands
# Sources:  DocStrings/Comments, https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html
#           Python Coding conventions, https://www.python.org/dev/peps/pep-0008/#source-file-encoding
# ****************************************************

import os
import sys
import time
import threading
import subprocess
from datetime import datetime
from datetime import timedelta
import concurrent.futures
from ErrorHandler import ErrorHandler
from Commands import Commands
from UserInput import UserInput
from VLCMan import VLCMan
from EtherTalk import EtherTalk
from MessageMan import MessageMan
from constants import *
from OrderCode import *
from Device import Device
import Commands as c_queue
c_queue.init()


class PiMan:
    def __init__(self, error_handler=None):
        self.is_shutdown_time = False
        self.leader_response_time = None
        self.has_follower = False
        self.eh = error_handler
        self.timestamp = datetime.now() + timedelta(seconds=IDLE_SEND_TIME)
        self.has_checked_ping = False

    def waiting_loop(self) -&gt; bool:
        &#34;&#34;&#34; This is the main-loop, active function for this program. It checks 
        for input from a user or other RasPis, and calls appropriate functions 
        when needed.

        Args:
            None

        Returns:
            bool: The return value indicates if everything closed properly.
                True for success, False otherwise.
        &#34;&#34;&#34;
        # Get object resources up and running
        et = EtherTalk(error_handler=self.eh, verbose=False)
        mm = MessageMan(error_handler=self.eh)
        vlc = VLCMan(VIDEOS_PATH, PLAYLIST_NAME, &#34;&#34;, error_handler=self.eh)
        device = Device().has_device

        if not self.get_started(vlc, et, mm, device):
            # Problem at startup, restart from scratch
            os.system(&#39;sudo shutdown -r now&#39;)

        self.time = datetime.now().second
        while not self.is_shutdown_time:
            # If leader check for user input and send commands
            if c_queue.IsLeader == True:
                device = Device().has_device
                self.next_command(vlc, et, mm, device)
                # Check to make sure a follower is still on the network
                if datetime.now().second &gt; 57 and not self.has_checked_ping:
                    # Loop for three seconds, pinging the follower for a response
                    loop_end_time = datetime.now() + timedelta(seconds=3)
                    self.has_checked_ping = True
                    while True:
                        if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.PING_RESPONSE):
                            break
                        elif datetime.now() &gt;= loop_end_time:
                            self.has_follower = False
                            break
                elif datetime.now().second &gt; 53 and datetime.now().second &lt;= 56:
                    self.has_checked_ping = False
            else:  # RasPi is the follower
                # Check if we need to become leader, dequeue, execute commands
                self.next_command_follower(mm, vlc)

            # Check time for shutdown
            self.is_shutdown_time = self.check_time()

        # Out of the Loop means it is Shutdown time for all units
        # Send shutdown signal 5 times, in case of false negative
        for i in range(4):
            if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.SHUT_DOWN):
                break
            time.sleep(5)
            
        # Then shutdown
        self.shutdown()

    def get_started(self, vlc, et, mm, device) -&gt; bool:
        &#34;&#34;&#34; Responsible for getting ready all pre-visual settings

        Args:
            vlc (VLCMan): VLC manager with current playlist information
            et (EtherTalk): Communicator to other Raspis on the network
            mm (MessageMan): Information manager to compose/parse communications

        Returns:
            bool: True indicates that this unit is the leader, and needs to 
            send out the playlist it created, False indicates it is the 
            follower, and will have waited for the new playlist within this 
            function.
        &#34;&#34;&#34;
        try:
            os.remove(PLAYLIST_NAME)
        except:
            pass

        try:
            # Check for usb device, this unit should be the Follower if
            # not found and no one else is on the network. Performed for 3 minutes.
            if not device:
                if et.ping() == 0:
                    print(&#34;[!] I am the follower (งツ)ว&#34;)
                    c_queue.IsLeader = False
                    self.listener(vlc, et)
                else:
                    print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                    c_queue.IsLeader = True
                    UserInput(self.eh).input_listener()
            else:
                print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                c_queue.IsLeader = True
                UserInput(self.eh).input_listener()
        except Exception as e:  # Something went wrong with the startup
            self.eh.log_error(e)
            return False

        # Playlist setup logic. Dependant on isLeader status
        try:
            # This is the Leader RasPi
            if c_queue.IsLeader == True:
                self.create_playlist(vlc)
            else:
                vlc.start_vlc()

        except Exception as e:
            self.eh.log_error(e)
            return False
        # This point indicates no major exceptions have occurred for either the
        # Leader or the Follower
        return True

    def shutdown(self):
        &#34;&#34;&#34; Safely exits and shuts down the RasPi unit

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        subprocess.Popen(&#34;sudo shutdown -P now&#34;, shell=True)

    def check_time(self) -&gt; bool:
        &#34;&#34;&#34; Keeps track of the time for autoshutdown and syncing with other
        RasPis on the network

        Args:
            None

        Returns:
            bool: True means the Pi should shutdown, False the program should 
            continue.
        &#34;&#34;&#34;
        # NOTE: Remove after testing. Returns False so that it doesn&#39;t shutdown with testing
        return False
    
        hour = datetime.now().hour
        if hour &gt;= SEVEN_AM and hour &lt; SEVEN_PM:
            return True
        else:
            return False

    def exec_command(self, vlc, time_start, command) -&gt; bool:
        &#34;&#34;&#34; Executes the argument `command` at the future start time.

        Args:
            vlc (VLCMan): VLC manager with current playlist information
            time_start (datetime.datetime): Future time to execute the order at
            command (OrderCode): Command to execute

        Returns:
            bool: True if successful, False if command is NONE or unsuccessful.
        &#34;&#34;&#34;
        # Wait until the exact time we need to do the command
        while datetime.now() &lt; time_start:
            pass
        
        if command == OrderCode.SHUT_DOWN:
            self.is_shutdown_time = True
            return True
        elif command == OrderCode.PLAYLIST:
            vlc.start_vlc()
            return True
        elif command == OrderCode.SLOW_DOWN:
            vlc.set_rate(-.1)
            return True
        elif command == OrderCode.SPEED_UP:
            vlc.set_rate(.1)
            return True
        elif command == OrderCode.LOOP_PLAY:
            vlc.toggle_loop_video()
            return True
        elif command == OrderCode.RESUME_LIST:
            vlc.reset_rate()
            vlc.next_video()
            return True
        elif command == OrderCode.RESUME_SPEED:
            vlc.reset_rate()
            return True
        elif command == OrderCode.PAUSE_PLAYBACK:
            vlc.play_pause_video()
            return True
        elif command == OrderCode.NEXT_VIDEO:
            vlc.next_video()
            vlc.set_loop_playlist()
            return True
        elif command == OrderCode.IDLE:
            return True
        elif command == OrderCode.NONE:
            return False
        return False

    def create_playlist(self, vlc):
        &#34;&#34;&#34; Update playlist information and package it in the message manager
        for transmission to other networked RasPis.

        Args:
            mm (MessageMan): The order information manager to compose and
                parse communications
            vlc (VLCMan): The VLC manager with current playlist and
                song information

        Returns: 
            None
        &#34;&#34;&#34;
        try:
            if vlc.randomize_videos():
                print(&#34;Videos Randomized&#34;)
            if vlc.create_playlist():
                print(&#34;Playlist Created&#34;)
            if vlc.start_vlc():
                print(&#34;VLC Started&#34;)
        except Exception as e:
            self.eh.log_error(e)
            raise

    def send_orders(self, message, et, mm, time_start, command) -&gt; bool:
        &#34;&#34;&#34; Issue instructions to other RasPis on the network

        Args:
            message (str): unused
            et (EtherTalk): The ethernet communication handler instance
            mm (MessageMan): The order information manager to compose and
                parse communications
            time_start (int): time offset for when the command will start
            command (enum OrderCode): command to be sent

        Returns:
            bool: True indicates that another RasPi has responded to the order,
                False indicates that either there was no answer,
                or an unrecoverable error has occurred for the other unit.
        &#34;&#34;&#34;
        # Create dict to send
        message_dict = mm.compose_message(message, time_start, command)
        if et.send(message_dict) == 0:
            return True
        return False

    def next_command(self, vlc, et, mm, device):
        &#34;&#34;&#34; Issue instructions to other host on the network

        Args:
            vlc (VLCMan): The VLC manager with current playlist and
                song information
            et (EtherTalk): The ethernet communication handler instance
            mm (MessageMan): The order information manager to compose and
                parse communications

        Returns:
            bool: True indicates that another RasPi has responded to the order,
                False indicates that either there was no answer,
                or an unrecoverable error has occurred for the other unit.
        &#34;&#34;&#34;
        try:
            # No mouse input and no queue, listen for another leader and give up Leadership
            if c_queue.CommandQueue.empty() and not device:
                if et.ping(45) == 0:
                    print(&#34;[!] I am the follower (งツ)ว&#34;)
                    c_queue.IsLeader = False
                    self.listener(vlc, et)
                    Commands(self.eh).flush_queue()
                    return
            # If we have something in our queue 
            elif not c_queue.CommandQueue.empty():
                # Grab next dict head from queue
                command_header = Commands(self.eh).dequeue()
                code = command_header[&#39;code&#39;]
                # If this comes back false, we have no follower
                if self.send_orders(&#34;&#34;, et, mm, START_TIME, OrderCode(command_header[&#39;code&#39;])):
                    # If we didn&#39;t already have a follower, send the playlist
                    if not self.has_follower:
                        # Generate header to send playlist
                        header = mm.compose_message(
                            &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                        et.send_file(header, PLAYLIST_NAME)
                        Commands(self.eh).flush_queue()
                        code = OrderCode.PLAYLIST
                        mm.start_time += 0.6
                    self.has_follower = True
                # We are leader, if execution is OK,
                if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                    self.leader_response_time = None
            # Otherwise, send IDLE to follower to indicate we are still alive every 10 seconds
            elif self.timestamp &lt; datetime.now():
                self.timestamp = datetime.now() + timedelta(seconds=IDLE_SEND_TIME)
                code = OrderCode.IDLE
                # If we are successfully sending the idle, we still have follower
                if self.send_orders(&#34;&#34;, et, mm, START_TIME, code):
                    # If we didn&#39;t already have a follower, send the playlist
                    if not self.has_follower:
                        # Generate header to send playlist
                        header = mm.compose_message(
                            &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                        et.send_file(header, PLAYLIST_NAME)
                        Commands(self.eh).flush_queue()
                        code = OrderCode.PLAYLIST
                        mm.start_time += 0.6
                    self.has_follower = True
                if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                    self.leader_response_time = None
        except Exception as e:
            self.eh.log_error(e)
            raise

    def listener(self, vlc, et):
        &#34;&#34;&#34; Follower wrapper to spawn listener thread

        Args:
            et (EtherTalk): The Communicator to other Raspis on the network
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;
        thread = threading.Thread(
            target=self.__listener, args=(vlc, et), daemon=True)
        thread.start()

    def __listener(self, vlc, et):
        &#34;&#34;&#34; Follower unit listens for instructions from Leader

        Args:
            et (EtherTalk): The Communicator to other Raspis on the network
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;
        try:
            # Stop this thread if you are no longer a follower
            while c_queue.IsLeader == False:
                # Receive status and header to display
                status, header = et.listen(path=WRITE_PATH)
                if status == 0:
                    # If we&#39;re receiving a playlist, we want to clear our queue
                    # and immediately play playlist at start_time
                    if header[&#39;code&#39;] == OrderCode.SEND_FILE:
                        header[&#39;code&#39;] = OrderCode.PLAYLIST
                        Commands(self.eh).flush_queue()
                    # Enqueue the new command
                    Commands(self.eh).enqueue(header)
        except Exception as e:
            self.eh.log_error(e)
            raise

    def next_command_follower(self, mm, vlc):
        &#34;&#34;&#34; Checks to see if follower needs to take leader status. Executes 
        next command in queue regardless.

        Args:
            mm (MessageMan): The message interpretor for et communications
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;

        try:
            # I want to check for empty queue and not add &#34;NONE&#39;s&#34; on the queue.
            # I believe it is causing syncing problems, so only exec_command queue&#39;s
            # with commands in them, otherwise we are either not getting commands or
            # the commands being sent are taking awhile to get here/being processed.
            # So I set the takeover time to be 3 mins in the future from when we have
            # an empty queue.
            if c_queue.CommandQueue.empty() and self.leader_response_time is None:
                self.leader_response_time = datetime.now(
                ) + timedelta(minutes=FOLLOWER_TAKEOVER_WAIT)
                
            elif not c_queue.CommandQueue.empty():
                # Dequeue next command header to be executed
                command_header = Commands(self.eh).dequeue()
                command_code = command_header[&#39;code&#39;]
                command_start = datetime.fromtimestamp(
                    command_header[&#39;start_time&#39;])
                # Execute the command. NONE and an error will return False.
                if self.exec_command(vlc, command_start, command_code):
                    self.leader_response_time = None
            # We have waiting for a response from the leader and nothing.
            # So become the leader and start up the input listender.
            elif self.leader_response_time is not None and self.leader_response_time &lt; datetime.now():
                print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                # this should prob just restart the code from main....
                self.leader_response_time = None
                Commands(self.eh).flush_queue()
                c_queue.IsLeader = True
                UserInput(self.eh).input_listener()
        except Exception as e:
            self.eh.log_error(e)
            raise</code></pre>
                </details>
            </section>
            <section>
            </section>
            <section>
            </section>
            <section>
            </section>
            <section>
                <h2 class="section-title" id="header-classes">Classes</h2>
                <dl>
                    <dt id="PiMan.PiMan"><code class="flex name class">
<span>class <span class="ident">PiMan</span></span>
<span>(</span><span>error_handler=None)</span>
</code></dt>
                    <dd>
                        <section class="desc"></section>
                        <details class="source">
                            <summary>
                                <span>Expand source code</span>
                            </summary>
                            <pre><code class="python">class PiMan:
    def __init__(self, error_handler=None):
        self.is_shutdown_time = False
        self.leader_response_time = None
        self.has_follower = False
        self.eh = error_handler
        self.timestamp = datetime.now() + timedelta(seconds=IDLE_SEND_TIME)
        self.has_checked_ping = False

    def waiting_loop(self) -&gt; bool:
        &#34;&#34;&#34; This is the main-loop, active function for this program. It checks 
        for input from a user or other RasPis, and calls appropriate functions 
        when needed.

        Args:
            None

        Returns:
            bool: The return value indicates if everything closed properly.
                True for success, False otherwise.
        &#34;&#34;&#34;
        # Get object resources up and running
        et = EtherTalk(error_handler=self.eh, verbose=False)
        mm = MessageMan(error_handler=self.eh)
        vlc = VLCMan(VIDEOS_PATH, PLAYLIST_NAME, &#34;&#34;, error_handler=self.eh)
        device = Device().has_device

        if not self.get_started(vlc, et, mm, device):
            # Problem at startup, restart from scratch
            os.system(&#39;sudo shutdown -r now&#39;)

        self.time = datetime.now().second
        while not self.is_shutdown_time:
            # If leader check for user input and send commands
            if c_queue.IsLeader == True:
                device = Device().has_device
                self.next_command(vlc, et, mm, device)
                # Check to make sure a follower is still on the network
                if datetime.now().second &gt; 57 and not self.has_checked_ping:
                    # Loop for three seconds, pinging the follower for a response
                    loop_end_time = datetime.now() + timedelta(seconds=3)
                    self.has_checked_ping = True
                    while True:
                        if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.PING_RESPONSE):
                            break
                        elif datetime.now() &gt;= loop_end_time:
                            self.has_follower = False
                            break
                elif datetime.now().second &gt; 53 and datetime.now().second &lt;= 56:
                    self.has_checked_ping = False
            else:  # RasPi is the follower
                # Check if we need to become leader, dequeue, execute commands
                self.next_command_follower(mm, vlc)

            # Check time for shutdown
            self.is_shutdown_time = self.check_time()

        # Out of the Loop means it is Shutdown time for all units
        # Send shutdown signal 5 times, in case of false negative
        for i in range(4):
            if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.SHUT_DOWN):
                break
            time.sleep(5)
            
        # Then shutdown
        self.shutdown()

    def get_started(self, vlc, et, mm, device) -&gt; bool:
        &#34;&#34;&#34; Responsible for getting ready all pre-visual settings

        Args:
            vlc (VLCMan): VLC manager with current playlist information
            et (EtherTalk): Communicator to other Raspis on the network
            mm (MessageMan): Information manager to compose/parse communications

        Returns:
            bool: True indicates that this unit is the leader, and needs to 
            send out the playlist it created, False indicates it is the 
            follower, and will have waited for the new playlist within this 
            function.
        &#34;&#34;&#34;
        try:
            os.remove(PLAYLIST_NAME)
        except:
            pass

        try:
            # Check for usb device, this unit should be the Follower if
            # not found and no one else is on the network. Performed for 3 minutes.
            if not device:
                if et.ping() == 0:
                    print(&#34;[!] I am the follower (งツ)ว&#34;)
                    c_queue.IsLeader = False
                    self.listener(vlc, et)
                else:
                    print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                    c_queue.IsLeader = True
                    UserInput(self.eh).input_listener()
            else:
                print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                c_queue.IsLeader = True
                UserInput(self.eh).input_listener()
        except Exception as e:  # Something went wrong with the startup
            self.eh.log_error(e)
            return False

        # Playlist setup logic. Dependant on isLeader status
        try:
            # This is the Leader RasPi
            if c_queue.IsLeader == True:
                self.create_playlist(vlc)
            else:
                vlc.start_vlc()

        except Exception as e:
            self.eh.log_error(e)
            return False
        # This point indicates no major exceptions have occurred for either the
        # Leader or the Follower
        return True

    def shutdown(self):
        &#34;&#34;&#34; Safely exits and shuts down the RasPi unit

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        subprocess.Popen(&#34;sudo shutdown -P now&#34;, shell=True)

    def check_time(self) -&gt; bool:
        &#34;&#34;&#34; Keeps track of the time for autoshutdown and syncing with other
        RasPis on the network

        Args:
            None

        Returns:
            bool: True means the Pi should shutdown, False the program should 
            continue.
        &#34;&#34;&#34;
        # NOTE: Remove after testing. Returns False so that it doesn&#39;t shutdown with testing
        return False
    
        hour = datetime.now().hour
        if hour &gt;= SEVEN_AM and hour &lt; SEVEN_PM:
            return True
        else:
            return False

    def exec_command(self, vlc, time_start, command) -&gt; bool:
        &#34;&#34;&#34; Executes the argument `command` at the future start time.

        Args:
            vlc (VLCMan): VLC manager with current playlist information
            time_start (datetime.datetime): Future time to execute the order at
            command (OrderCode): Command to execute

        Returns:
            bool: True if successful, False if command is NONE or unsuccessful.
        &#34;&#34;&#34;
        # Wait until the exact time we need to do the command
        while datetime.now() &lt; time_start:
            pass
        
        if command == OrderCode.SHUT_DOWN:
            self.is_shutdown_time = True
            return True
        elif command == OrderCode.PLAYLIST:
            vlc.start_vlc()
            return True
        elif command == OrderCode.SLOW_DOWN:
            vlc.set_rate(-.1)
            return True
        elif command == OrderCode.SPEED_UP:
            vlc.set_rate(.1)
            return True
        elif command == OrderCode.LOOP_PLAY:
            vlc.toggle_loop_video()
            return True
        elif command == OrderCode.RESUME_LIST:
            vlc.reset_rate()
            vlc.next_video()
            return True
        elif command == OrderCode.RESUME_SPEED:
            vlc.reset_rate()
            return True
        elif command == OrderCode.PAUSE_PLAYBACK:
            vlc.play_pause_video()
            return True
        elif command == OrderCode.NEXT_VIDEO:
            vlc.next_video()
            vlc.set_loop_playlist()
            return True
        elif command == OrderCode.IDLE:
            return True
        elif command == OrderCode.NONE:
            return False
        return False

    def create_playlist(self, vlc):
        &#34;&#34;&#34; Update playlist information and package it in the message manager
        for transmission to other networked RasPis.

        Args:
            mm (MessageMan): The order information manager to compose and
                parse communications
            vlc (VLCMan): The VLC manager with current playlist and
                song information

        Returns: 
            None
        &#34;&#34;&#34;
        try:
            if vlc.randomize_videos():
                print(&#34;Videos Randomized&#34;)
            if vlc.create_playlist():
                print(&#34;Playlist Created&#34;)
            if vlc.start_vlc():
                print(&#34;VLC Started&#34;)
        except Exception as e:
            self.eh.log_error(e)
            raise

    def send_orders(self, message, et, mm, time_start, command) -&gt; bool:
        &#34;&#34;&#34; Issue instructions to other RasPis on the network

        Args:
            message (str): unused
            et (EtherTalk): The ethernet communication handler instance
            mm (MessageMan): The order information manager to compose and
                parse communications
            time_start (int): time offset for when the command will start
            command (enum OrderCode): command to be sent

        Returns:
            bool: True indicates that another RasPi has responded to the order,
                False indicates that either there was no answer,
                or an unrecoverable error has occurred for the other unit.
        &#34;&#34;&#34;
        # Create dict to send
        message_dict = mm.compose_message(message, time_start, command)
        if et.send(message_dict) == 0:
            return True
        return False

    def next_command(self, vlc, et, mm, device):
        &#34;&#34;&#34; Issue instructions to other host on the network

        Args:
            vlc (VLCMan): The VLC manager with current playlist and
                song information
            et (EtherTalk): The ethernet communication handler instance
            mm (MessageMan): The order information manager to compose and
                parse communications

        Returns:
            bool: True indicates that another RasPi has responded to the order,
                False indicates that either there was no answer,
                or an unrecoverable error has occurred for the other unit.
        &#34;&#34;&#34;
        try:
            # No mouse input and no queue, listen for another leader and give up Leadership
            if c_queue.CommandQueue.empty() and not device:
                if et.ping(45) == 0:
                    print(&#34;[!] I am the follower (งツ)ว&#34;)
                    c_queue.IsLeader = False
                    self.listener(vlc, et)
                    Commands(self.eh).flush_queue()
                    return
            # If we have something in our queue 
            elif not c_queue.CommandQueue.empty():
                # Grab next dict head from queue
                command_header = Commands(self.eh).dequeue()
                code = command_header[&#39;code&#39;]
                # If this comes back false, we have no follower
                if self.send_orders(&#34;&#34;, et, mm, START_TIME, OrderCode(command_header[&#39;code&#39;])):
                    # If we didn&#39;t already have a follower, send the playlist
                    if not self.has_follower:
                        # Generate header to send playlist
                        header = mm.compose_message(
                            &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                        et.send_file(header, PLAYLIST_NAME)
                        Commands(self.eh).flush_queue()
                        code = OrderCode.PLAYLIST
                        mm.start_time += 0.6
                    self.has_follower = True
                # We are leader, if execution is OK,
                if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                    self.leader_response_time = None
            # Otherwise, send IDLE to follower to indicate we are still alive every 10 seconds
            elif self.timestamp &lt; datetime.now():
                self.timestamp = datetime.now() + timedelta(seconds=IDLE_SEND_TIME)
                code = OrderCode.IDLE
                # If we are successfully sending the idle, we still have follower
                if self.send_orders(&#34;&#34;, et, mm, START_TIME, code):
                    # If we didn&#39;t already have a follower, send the playlist
                    if not self.has_follower:
                        # Generate header to send playlist
                        header = mm.compose_message(
                            &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                        et.send_file(header, PLAYLIST_NAME)
                        Commands(self.eh).flush_queue()
                        code = OrderCode.PLAYLIST
                        mm.start_time += 0.6
                    self.has_follower = True
                if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                    self.leader_response_time = None
        except Exception as e:
            self.eh.log_error(e)
            raise

    def listener(self, vlc, et):
        &#34;&#34;&#34; Follower wrapper to spawn listener thread

        Args:
            et (EtherTalk): The Communicator to other Raspis on the network
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;
        thread = threading.Thread(
            target=self.__listener, args=(vlc, et), daemon=True)
        thread.start()

    def __listener(self, vlc, et):
        &#34;&#34;&#34; Follower unit listens for instructions from Leader

        Args:
            et (EtherTalk): The Communicator to other Raspis on the network
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;
        try:
            # Stop this thread if you are no longer a follower
            while c_queue.IsLeader == False:
                # Receive status and header to display
                status, header = et.listen(path=WRITE_PATH)
                if status == 0:
                    # If we&#39;re receiving a playlist, we want to clear our queue
                    # and immediately play playlist at start_time
                    if header[&#39;code&#39;] == OrderCode.SEND_FILE:
                        header[&#39;code&#39;] = OrderCode.PLAYLIST
                        Commands(self.eh).flush_queue()
                    # Enqueue the new command
                    Commands(self.eh).enqueue(header)
        except Exception as e:
            self.eh.log_error(e)
            raise

    def next_command_follower(self, mm, vlc):
        &#34;&#34;&#34; Checks to see if follower needs to take leader status. Executes 
        next command in queue regardless.

        Args:
            mm (MessageMan): The message interpretor for et communications
            vlc (VLCMan): VLC manager with current playlist information

        Returns:
            None
        &#34;&#34;&#34;

        try:
            # I want to check for empty queue and not add &#34;NONE&#39;s&#34; on the queue.
            # I believe it is causing syncing problems, so only exec_command queue&#39;s
            # with commands in them, otherwise we are either not getting commands or
            # the commands being sent are taking awhile to get here/being processed.
            # So I set the takeover time to be 3 mins in the future from when we have
            # an empty queue.
            if c_queue.CommandQueue.empty() and self.leader_response_time is None:
                self.leader_response_time = datetime.now(
                ) + timedelta(minutes=FOLLOWER_TAKEOVER_WAIT)
                
            elif not c_queue.CommandQueue.empty():
                # Dequeue next command header to be executed
                command_header = Commands(self.eh).dequeue()
                command_code = command_header[&#39;code&#39;]
                command_start = datetime.fromtimestamp(
                    command_header[&#39;start_time&#39;])
                # Execute the command. NONE and an error will return False.
                if self.exec_command(vlc, command_start, command_code):
                    self.leader_response_time = None
            # We have waiting for a response from the leader and nothing.
            # So become the leader and start up the input listender.
            elif self.leader_response_time is not None and self.leader_response_time &lt; datetime.now():
                print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                # this should prob just restart the code from main....
                self.leader_response_time = None
                Commands(self.eh).flush_queue()
                c_queue.IsLeader = True
                UserInput(self.eh).input_listener()
        except Exception as e:
            self.eh.log_error(e)
            raise</code></pre>
                        </details>
                        <h3>Methods</h3>
                        <dl>
                            <dt id="PiMan.PiMan.check_time"><code class="name flex">
<span>def <span class="ident">check_time</span></span>(<span>self)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Keeps track of the time for autoshutdown and syncing with other
                                        RasPis on the network</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>None</code></strong></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>True means the Pi should shutdown, False the program should </dd>
                                    </dl>
                                    <p>continue.</p>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def check_time(self) -&gt; bool:
    &#34;&#34;&#34; Keeps track of the time for autoshutdown and syncing with other
    RasPis on the network

    Args:
        None

    Returns:
        bool: True means the Pi should shutdown, False the program should 
        continue.
    &#34;&#34;&#34;
    # NOTE: Remove after testing. Returns False so that it doesn&#39;t shutdown with testing
    return False

    hour = datetime.now().hour
    if hour &gt;= SEVEN_AM and hour &lt; SEVEN_PM:
        return True
    else:
        return False</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.create_playlist"><code class="name flex">
<span>def <span class="ident">create_playlist</span></span>(<span>self, vlc)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Update playlist information and package it in the message manager
                                        for transmission to other networked RasPis.</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>mm</code></strong> :&ensp;<a title="MessageMan"
                                                href="MessageMan.html"><code>MessageMan</code></a></dt>
                                        <dd>The order information manager to compose and
                                            parse communications</dd>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>The VLC manager with current playlist and
                                            song information</dd>
                                        <dt><strong><code>Returns</code></strong></dt>
                                        <dd>None</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def create_playlist(self, vlc):
    &#34;&#34;&#34; Update playlist information and package it in the message manager
    for transmission to other networked RasPis.

    Args:
        mm (MessageMan): The order information manager to compose and
            parse communications
        vlc (VLCMan): The VLC manager with current playlist and
            song information

    Returns: 
        None
    &#34;&#34;&#34;
    try:
        if vlc.randomize_videos():
            print(&#34;Videos Randomized&#34;)
        if vlc.create_playlist():
            print(&#34;Playlist Created&#34;)
        if vlc.start_vlc():
            print(&#34;VLC Started&#34;)
    except Exception as e:
        self.eh.log_error(e)
        raise</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.exec_command"><code class="name flex">
<span>def <span class="ident">exec_command</span></span>(<span>self, vlc, time_start, command)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Executes the argument <code>command</code> at the future start time.</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>VLC manager with current playlist information</dd>
                                        <dt><strong><code>time_start</code></strong>
                                            :&ensp;<code>datetime.datetime</code></dt>
                                        <dd>Future time to execute the order at</dd>
                                        <dt><strong><code>command</code></strong> :&ensp;<a title="OrderCode"
                                                href="OrderCode.html"><code>OrderCode</code></a></dt>
                                        <dd>Command to execute</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>True if successful, False if command is NONE or unsuccessful.</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def exec_command(self, vlc, time_start, command) -&gt; bool:
    &#34;&#34;&#34; Executes the argument `command` at the future start time.

    Args:
        vlc (VLCMan): VLC manager with current playlist information
        time_start (datetime.datetime): Future time to execute the order at
        command (OrderCode): Command to execute

    Returns:
        bool: True if successful, False if command is NONE or unsuccessful.
    &#34;&#34;&#34;
    # Wait until the exact time we need to do the command
    while datetime.now() &lt; time_start:
        pass
    
    if command == OrderCode.SHUT_DOWN:
        self.is_shutdown_time = True
        return True
    elif command == OrderCode.PLAYLIST:
        vlc.start_vlc()
        return True
    elif command == OrderCode.SLOW_DOWN:
        vlc.set_rate(-.1)
        return True
    elif command == OrderCode.SPEED_UP:
        vlc.set_rate(.1)
        return True
    elif command == OrderCode.LOOP_PLAY:
        vlc.toggle_loop_video()
        return True
    elif command == OrderCode.RESUME_LIST:
        vlc.reset_rate()
        vlc.next_video()
        return True
    elif command == OrderCode.RESUME_SPEED:
        vlc.reset_rate()
        return True
    elif command == OrderCode.PAUSE_PLAYBACK:
        vlc.play_pause_video()
        return True
    elif command == OrderCode.NEXT_VIDEO:
        vlc.next_video()
        vlc.set_loop_playlist()
        return True
    elif command == OrderCode.IDLE:
        return True
    elif command == OrderCode.NONE:
        return False
    return False</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.get_started"><code class="name flex">
<span>def <span class="ident">get_started</span></span>(<span>self, vlc, et, mm, device)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Responsible for getting ready all pre-visual settings</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>VLC manager with current playlist information</dd>
                                        <dt><strong><code>et</code></strong> :&ensp;<a title="EtherTalk"
                                                href="EtherTalk.html"><code>EtherTalk</code></a></dt>
                                        <dd>Communicator to other Raspis on the network</dd>
                                        <dt><strong><code>mm</code></strong> :&ensp;<a title="MessageMan"
                                                href="MessageMan.html"><code>MessageMan</code></a></dt>
                                        <dd>Information manager to compose/parse communications</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>True indicates that this unit is the leader, and needs to </dd>
                                        <dt><code>send</code> <code>out</code> <code>the</code> <code>playlist</code>
                                            <code>it</code> <code>created</code>, <code>False</code>
                                            <code>indicates</code> <code>it</code> <code>is</code> <code>the</code></dt>
                                        <dd>&nbsp;</dd>
                                        <dt><code>follower</code>, <code>and</code> <code>will</code> <code>have</code>
                                            <code>waited</code> <code>for</code> <code>the</code> <code>new</code>
                                            <code>playlist</code> <code>within</code> <code>this</code></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                    <p>function.</p>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def get_started(self, vlc, et, mm, device) -&gt; bool:
    &#34;&#34;&#34; Responsible for getting ready all pre-visual settings

    Args:
        vlc (VLCMan): VLC manager with current playlist information
        et (EtherTalk): Communicator to other Raspis on the network
        mm (MessageMan): Information manager to compose/parse communications

    Returns:
        bool: True indicates that this unit is the leader, and needs to 
        send out the playlist it created, False indicates it is the 
        follower, and will have waited for the new playlist within this 
        function.
    &#34;&#34;&#34;
    try:
        os.remove(PLAYLIST_NAME)
    except:
        pass

    try:
        # Check for usb device, this unit should be the Follower if
        # not found and no one else is on the network. Performed for 3 minutes.
        if not device:
            if et.ping() == 0:
                print(&#34;[!] I am the follower (งツ)ว&#34;)
                c_queue.IsLeader = False
                self.listener(vlc, et)
            else:
                print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
                c_queue.IsLeader = True
                UserInput(self.eh).input_listener()
        else:
            print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
            c_queue.IsLeader = True
            UserInput(self.eh).input_listener()
    except Exception as e:  # Something went wrong with the startup
        self.eh.log_error(e)
        return False

    # Playlist setup logic. Dependant on isLeader status
    try:
        # This is the Leader RasPi
        if c_queue.IsLeader == True:
            self.create_playlist(vlc)
        else:
            vlc.start_vlc()

    except Exception as e:
        self.eh.log_error(e)
        return False
    # This point indicates no major exceptions have occurred for either the
    # Leader or the Follower
    return True</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.listener"><code class="name flex">
<span>def <span class="ident">listener</span></span>(<span>self, vlc, et)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Follower wrapper to spawn listener thread</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>et</code></strong> :&ensp;<a title="EtherTalk"
                                                href="EtherTalk.html"><code>EtherTalk</code></a></dt>
                                        <dd>The Communicator to other Raspis on the network</dd>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>VLC manager with current playlist information</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><code>None</code></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def listener(self, vlc, et):
    &#34;&#34;&#34; Follower wrapper to spawn listener thread

    Args:
        et (EtherTalk): The Communicator to other Raspis on the network
        vlc (VLCMan): VLC manager with current playlist information

    Returns:
        None
    &#34;&#34;&#34;
    thread = threading.Thread(
        target=self.__listener, args=(vlc, et), daemon=True)
    thread.start()</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.next_command"><code class="name flex">
<span>def <span class="ident">next_command</span></span>(<span>self, vlc, et, mm, device)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Issue instructions to other host on the network</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>The VLC manager with current playlist and
                                            song information</dd>
                                        <dt><strong><code>et</code></strong> :&ensp;<a title="EtherTalk"
                                                href="EtherTalk.html"><code>EtherTalk</code></a></dt>
                                        <dd>The ethernet communication handler instance</dd>
                                        <dt><strong><code>mm</code></strong> :&ensp;<a title="MessageMan"
                                                href="MessageMan.html"><code>MessageMan</code></a></dt>
                                        <dd>The order information manager to compose and
                                            parse communications</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>True indicates that another RasPi has responded to the order,
                                            False indicates that either there was no answer,
                                            or an unrecoverable error has occurred for the other unit.</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def next_command(self, vlc, et, mm, device):
    &#34;&#34;&#34; Issue instructions to other host on the network

    Args:
        vlc (VLCMan): The VLC manager with current playlist and
            song information
        et (EtherTalk): The ethernet communication handler instance
        mm (MessageMan): The order information manager to compose and
            parse communications

    Returns:
        bool: True indicates that another RasPi has responded to the order,
            False indicates that either there was no answer,
            or an unrecoverable error has occurred for the other unit.
    &#34;&#34;&#34;
    try:
        # No mouse input and no queue, listen for another leader and give up Leadership
        if c_queue.CommandQueue.empty() and not device:
            if et.ping(45) == 0:
                print(&#34;[!] I am the follower (งツ)ว&#34;)
                c_queue.IsLeader = False
                self.listener(vlc, et)
                Commands(self.eh).flush_queue()
                return
        # If we have something in our queue 
        elif not c_queue.CommandQueue.empty():
            # Grab next dict head from queue
            command_header = Commands(self.eh).dequeue()
            code = command_header[&#39;code&#39;]
            # If this comes back false, we have no follower
            if self.send_orders(&#34;&#34;, et, mm, START_TIME, OrderCode(command_header[&#39;code&#39;])):
                # If we didn&#39;t already have a follower, send the playlist
                if not self.has_follower:
                    # Generate header to send playlist
                    header = mm.compose_message(
                        &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                    et.send_file(header, PLAYLIST_NAME)
                    Commands(self.eh).flush_queue()
                    code = OrderCode.PLAYLIST
                    mm.start_time += 0.6
                self.has_follower = True
            # We are leader, if execution is OK,
            if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                self.leader_response_time = None
        # Otherwise, send IDLE to follower to indicate we are still alive every 10 seconds
        elif self.timestamp &lt; datetime.now():
            self.timestamp = datetime.now() + timedelta(seconds=IDLE_SEND_TIME)
            code = OrderCode.IDLE
            # If we are successfully sending the idle, we still have follower
            if self.send_orders(&#34;&#34;, et, mm, START_TIME, code):
                # If we didn&#39;t already have a follower, send the playlist
                if not self.has_follower:
                    # Generate header to send playlist
                    header = mm.compose_message(
                        &#34;&#34;, PLAYLIST_START_TIME, OrderCode.SEND_FILE)
                    et.send_file(header, PLAYLIST_NAME)
                    Commands(self.eh).flush_queue()
                    code = OrderCode.PLAYLIST
                    mm.start_time += 0.6
                self.has_follower = True
            if self.exec_command(vlc, datetime.fromtimestamp(mm.start_time), code):
                self.leader_response_time = None
    except Exception as e:
        self.eh.log_error(e)
        raise</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.next_command_follower"><code class="name flex">
<span>def <span class="ident">next_command_follower</span></span>(<span>self, mm, vlc)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Checks to see if follower needs to take leader status. Executes
                                        next command in queue regardless.</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>mm</code></strong> :&ensp;<a title="MessageMan"
                                                href="MessageMan.html"><code>MessageMan</code></a></dt>
                                        <dd>The message interpretor for et communications</dd>
                                        <dt><strong><code>vlc</code></strong> :&ensp;<a title="VLCMan"
                                                href="VLCMan.html"><code>VLCMan</code></a></dt>
                                        <dd>VLC manager with current playlist information</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><code>None</code></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def next_command_follower(self, mm, vlc):
    &#34;&#34;&#34; Checks to see if follower needs to take leader status. Executes 
    next command in queue regardless.

    Args:
        mm (MessageMan): The message interpretor for et communications
        vlc (VLCMan): VLC manager with current playlist information

    Returns:
        None
    &#34;&#34;&#34;

    try:
        # I want to check for empty queue and not add &#34;NONE&#39;s&#34; on the queue.
        # I believe it is causing syncing problems, so only exec_command queue&#39;s
        # with commands in them, otherwise we are either not getting commands or
        # the commands being sent are taking awhile to get here/being processed.
        # So I set the takeover time to be 3 mins in the future from when we have
        # an empty queue.
        if c_queue.CommandQueue.empty() and self.leader_response_time is None:
            self.leader_response_time = datetime.now(
            ) + timedelta(minutes=FOLLOWER_TAKEOVER_WAIT)
            
        elif not c_queue.CommandQueue.empty():
            # Dequeue next command header to be executed
            command_header = Commands(self.eh).dequeue()
            command_code = command_header[&#39;code&#39;]
            command_start = datetime.fromtimestamp(
                command_header[&#39;start_time&#39;])
            # Execute the command. NONE and an error will return False.
            if self.exec_command(vlc, command_start, command_code):
                self.leader_response_time = None
        # We have waiting for a response from the leader and nothing.
        # So become the leader and start up the input listender.
        elif self.leader_response_time is not None and self.leader_response_time &lt; datetime.now():
            print(&#34;[!] I am the leader ᕕ( ᐛ )ᕗ&#34;)
            # this should prob just restart the code from main....
            self.leader_response_time = None
            Commands(self.eh).flush_queue()
            c_queue.IsLeader = True
            UserInput(self.eh).input_listener()
    except Exception as e:
        self.eh.log_error(e)
        raise</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.send_orders"><code class="name flex">
<span>def <span class="ident">send_orders</span></span>(<span>self, message, et, mm, time_start, command)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Issue instructions to other RasPis on the network</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
                                        <dd>unused</dd>
                                        <dt><strong><code>et</code></strong> :&ensp;<a title="EtherTalk"
                                                href="EtherTalk.html"><code>EtherTalk</code></a></dt>
                                        <dd>The ethernet communication handler instance</dd>
                                        <dt><strong><code>mm</code></strong> :&ensp;<a title="MessageMan"
                                                href="MessageMan.html"><code>MessageMan</code></a></dt>
                                        <dd>The order information manager to compose and
                                            parse communications</dd>
                                        <dt><strong><code>time_start</code></strong> :&ensp;<code>int</code></dt>
                                        <dd>time offset for when the command will start</dd>
                                        <dt><strong><code>command</code></strong> :&ensp;<code>enum</code> <a
                                                title="OrderCode" href="OrderCode.html"><code>OrderCode</code></a></dt>
                                        <dd>command to be sent</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>True indicates that another RasPi has responded to the order,
                                            False indicates that either there was no answer,
                                            or an unrecoverable error has occurred for the other unit.</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def send_orders(self, message, et, mm, time_start, command) -&gt; bool:
    &#34;&#34;&#34; Issue instructions to other RasPis on the network

    Args:
        message (str): unused
        et (EtherTalk): The ethernet communication handler instance
        mm (MessageMan): The order information manager to compose and
            parse communications
        time_start (int): time offset for when the command will start
        command (enum OrderCode): command to be sent

    Returns:
        bool: True indicates that another RasPi has responded to the order,
            False indicates that either there was no answer,
            or an unrecoverable error has occurred for the other unit.
    &#34;&#34;&#34;
    # Create dict to send
    message_dict = mm.compose_message(message, time_start, command)
    if et.send(message_dict) == 0:
        return True
    return False</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>Safely exits and shuts down the RasPi unit</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>None</code></strong></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><code>None</code></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def shutdown(self):
    &#34;&#34;&#34; Safely exits and shuts down the RasPi unit

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    subprocess.Popen(&#34;sudo shutdown -P now&#34;, shell=True)</code></pre>
                                </details>
                            </dd>
                            <dt id="PiMan.PiMan.waiting_loop"><code class="name flex">
<span>def <span class="ident">waiting_loop</span></span>(<span>self)</span>
</code></dt>
                            <dd>
                                <section class="desc">
                                    <p>This is the main-loop, active function for this program. It checks
                                        for input from a user or other RasPis, and calls appropriate functions
                                        when needed.</p>
                                    <h2 id="args">Args</h2>
                                    <dl>
                                        <dt><strong><code>None</code></strong></dt>
                                        <dd>&nbsp;</dd>
                                    </dl>
                                    <h2 id="returns">Returns</h2>
                                    <dl>
                                        <dt><strong><code>bool</code></strong></dt>
                                        <dd>The return value indicates if everything closed properly.
                                            True for success, False otherwise.</dd>
                                    </dl>
                                </section>
                                <details class="source">
                                    <summary>
                                        <span>Expand source code</span>
                                    </summary>
                                    <pre><code class="python">def waiting_loop(self) -&gt; bool:
    &#34;&#34;&#34; This is the main-loop, active function for this program. It checks 
    for input from a user or other RasPis, and calls appropriate functions 
    when needed.

    Args:
        None

    Returns:
        bool: The return value indicates if everything closed properly.
            True for success, False otherwise.
    &#34;&#34;&#34;
    # Get object resources up and running
    et = EtherTalk(error_handler=self.eh, verbose=False)
    mm = MessageMan(error_handler=self.eh)
    vlc = VLCMan(VIDEOS_PATH, PLAYLIST_NAME, &#34;&#34;, error_handler=self.eh)
    device = Device().has_device

    if not self.get_started(vlc, et, mm, device):
        # Problem at startup, restart from scratch
        os.system(&#39;sudo shutdown -r now&#39;)

    self.time = datetime.now().second
    while not self.is_shutdown_time:
        # If leader check for user input and send commands
        if c_queue.IsLeader == True:
            device = Device().has_device
            self.next_command(vlc, et, mm, device)
            # Check to make sure a follower is still on the network
            if datetime.now().second &gt; 57 and not self.has_checked_ping:
                # Loop for three seconds, pinging the follower for a response
                loop_end_time = datetime.now() + timedelta(seconds=3)
                self.has_checked_ping = True
                while True:
                    if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.PING_RESPONSE):
                        break
                    elif datetime.now() &gt;= loop_end_time:
                        self.has_follower = False
                        break
            elif datetime.now().second &gt; 53 and datetime.now().second &lt;= 56:
                self.has_checked_ping = False
        else:  # RasPi is the follower
            # Check if we need to become leader, dequeue, execute commands
            self.next_command_follower(mm, vlc)

        # Check time for shutdown
        self.is_shutdown_time = self.check_time()

    # Out of the Loop means it is Shutdown time for all units
    # Send shutdown signal 5 times, in case of false negative
    for i in range(4):
        if self.send_orders(&#34;&#34;, et, mm, 0, OrderCode.SHUT_DOWN):
            break
        time.sleep(5)
        
    # Then shutdown
    self.shutdown()</code></pre>
                                </details>
                            </dd>
                        </dl>
                    </dd>
                </dl>
            </section>
        </article>
        <nav id="sidebar">
            <h1><a title="DocIndex" href="DocIndex.html">&#8592;Back</a></h1>
            <h1>Index</h1>
            <div class="toc">
                <ul></ul>
            </div>
            <ul id="index">
                <li>
                    <h3><a href="#header-classes">Classes</a></h3>
                    <ul>
                        <li>
                            <h4><code><a title="PiMan.PiMan" href="#PiMan.PiMan">PiMan</a></code></h4>
                            <ul class="">
                                <li><code><a title="PiMan.PiMan.check_time" href="#PiMan.PiMan.check_time">check_time</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.create_playlist" href="#PiMan.PiMan.create_playlist">create_playlist</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.exec_command" href="#PiMan.PiMan.exec_command">exec_command</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.get_started" href="#PiMan.PiMan.get_started">get_started</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.listener" href="#PiMan.PiMan.listener">listener</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.next_command" href="#PiMan.PiMan.next_command">next_command</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.next_command_follower" href="#PiMan.PiMan.next_command_follower">next_command_follower</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.send_orders" href="#PiMan.PiMan.send_orders">send_orders</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.shutdown" href="#PiMan.PiMan.shutdown">shutdown</a></code>
                                </li>
                                <li><code><a title="PiMan.PiMan.waiting_loop" href="#PiMan.PiMan.waiting_loop">waiting_loop</a></code>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </nav>
    </main>
    <footer id="footer">
        <p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
    </footer>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad()</script>
</body>

</html>